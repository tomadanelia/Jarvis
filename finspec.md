# Robot Task Simulation: Developer Specification (Client-Server Architecture)

**Version:** 1.1
**Date:** October 26, 2023 (Updated [Current Date])

**Table of Contents:**
1.  [Project Overview](#1-project-overview)
    1.1. [Description](#11-description)
    1.2. [Architecture](#12-architecture)
2.  [Core Entities & Data Structures (TypeScript)](#2-core-entities--data-structures)
    2.1. [Grid Environment](#21-grid-environment)
    2.2. [Tasks](#22-tasks)
    2.3. [Robots](#23-robots)
    2.4. [Charging Stations](#24-charging-stations)
3.  [Backend Logic (Node.js/Express)](#3-backend-logic-nodejs-express)
    3.1. [Simulation Engine](#31-simulation-engine)
    3.2. [Time & Steps](#32-time--steps)
    3.3. [Pathfinding (A*)](#33-pathfinding-a)
    3.4. [Robot Movement & Collision Resolution](#34-robot-movement--collision-resolution)
    3.5. [Task Assignment Strategies](#35-task-assignment-strategies)
    3.6. [Battery Management & Charging](#36-battery-management--charging)
    3.7. [Task Processing](#37-task-processing)
    3.8. [Simulation Start & End Conditions](#38-simulation-start--end-conditions)
4.  [Frontend User Interface (UI) & Interaction (React)](#4-frontend-user-interface-ui--interaction-react)
    4.1. [Setup Phase](#41-setup-phase)
    4.2. [Simulation Controls](#42-simulation-controls)
    4.3. [Visual Display](#43-visual-display)
    4.4. [Information Display](#44-information-display)
5.  [Technical Architecture & Implementation Details](#5-technical-architecture--implementation-details)
    5.1. [Core Technologies](#51-core-technologies)
    5.2. [State Management](#52-state-management)
    5.3. [Communication (API & WebSockets)](#53-communication-api--websockets)
    5.4. [Backend Modularity](#54-backend-modularity)
    5.5. [Frontend Modularity](#55-frontend-modularity)
    5.6. [Database (Supabase)](#56-database-supabase)
6.  [Key Metrics for Comparison](#6-key-metrics-for-comparison)
7.  [Error Handling & Edge Cases](#7-error-handling--edge-cases)
8.  [Testing Plan](#8-testing-plan)
9.  [Future Considerations](#9-future-considerations)

---

## 1. Project Overview

### 1.1. Description
Develop a client-server application that simulates multiple simple robots performing tasks on a 2D grid. The **backend server** will manage the simulation state, execute all core logic (pathfinding, task assignment, robot actions), and persist key data. The **frontend client** will allow users to define a small grid environment, place "tasks" and "robots," and select task assignment strategies. The simulation will visually demonstrate robots moving, completing tasks, and managing battery, with changes rendered dynamically in the browser through real-time updates from the backend.

### 1.2. Architecture
*   **Backend:** Node.js with Express and TypeScript. Handles all simulation logic, state management for the active simulation, and communication with the database.
*   **Frontend:** React with TypeScript. Provides the user interface for setup, control, and visualization.
*   **Database:** Supabase (PostgreSQL) for storing grid definitions, and potentially robot/task configurations and simulation results/metrics.
*   **Real-time Communication:** WebSockets (e.g., using `socket.io`) will be used to broadcast simulation state changes from the backend to all connected clients, allowing multiple users to observe a running simulation in real-time. User authentication is not required for this version.

---

## 2. Core Entities & Data Structures (TypeScript)
*(These definitions will be shared or mirrored between backend and frontend where appropriate.)*

### 2.1. Grid Environment
*   **Representation:** A 2D array of `Cell` objects.
    ```typescript
    interface Cell {
        type: 'walkable' | 'wall' | 'charging_station';
        coordinates: { x: number; y: number };
    }
    ```
*   **Storage & Loading:**
    *   Grid definitions (e.g., `name` and `layout` as a 2D array of `Cell` types) will be stored in a Supabase table.
    *   Example structure for Supabase `grids` table: `id (PK)`, `name (TEXT)`, `layout (JSONB)`.
    *   Backend API will provide a list of available grids to the frontend.
*   **Selection:** Users select from a predefined list of grids fetched from the backend.
*   **Shape:** Grids can have non-rectangular navigable areas.

### 2.2. Tasks
*   **Properties:**
    ```typescript
    interface Task {
        id: string; // unique, generated by backend
        location: { x: number; y: number }; // grid coordinates
        status: 'unassigned' | 'assigned' | 'in_progress' | 'completed';
        workDuration: number; // fixed, e.g., 3 simulation steps
        batteryCostToPerform: number; // fixed, e.g., 2 units
        // Potentially: simulationSessionId (FK) if saving task states
    }
    ```
*   **Initial Type:** Uniform `workDuration` and `batteryCostToPerform`.
*   **Placement:** Frontend sends desired coordinates to backend. Backend validates placement on 'walkable' cells and creates the task.
*   **Completion:** Managed by backend logic.

### 2.3. Robots
*   **Properties:**
    ```typescript
    interface Robot {
        id: string; // unique, generated by backend
        iconType: string; // e.g., 'robot_icon_green.png', cycled from a predefined list
        currentLocation: { x: number; y: number };
        battery: number; // 0-100, starts full
        maxBattery: number; // e.g., 100
        status: 'idle' | 'en_route_to_task' | 'performing_task' | 'en_route_to_charger' | 'charging';
        assignedTaskId?: string;
        currentTarget?: { x: number; y: number };
        currentPath?: Array<{ x: number; y: number }>;
        movementCostPerCell: number; // fixed, e.g., 1 battery unit
        consecutiveWaitSteps: number; // default 0
        // Potentially: simulationSessionId (FK) if saving robot states
    }
    ```
*   **Placement:** Frontend sends desired coordinates to backend. Backend validates placement and creates the robot. Icon cycling logic can be on frontend for selection, or backend assigns.
*   **Initial State:** Full battery, `idle` status. Managed by backend.
*   **Robot Stats (Supabase):** Consider storing robot configurations (e.g., `maxBattery`, `movementCostPerCell`, available `iconType`s) or even aggregated performance stats in Supabase.

### 2.4. Charging Stations
*   Implicitly defined by `type: 'charging_station'` in the grid layout. Functionality managed by backend.

---

## 3. Backend Logic (Node.js/Express)
*(All simulation logic resides on the backend.)*

### 3.1. Simulation Engine
*   Core loop that advances the simulation step by step.
*   Manages the current state of all robots, tasks, and the environment for an active simulation session.
*   Communicates state updates to connected clients via WebSockets.

### 3.2. Time & Steps
*   The simulation progresses in discrete steps (ticks) managed by the backend.
*   **1 simulation step = 1 simulated second.**
*   Simulation run speed (real-time delay between backend steps) can be configurable via an API call from the frontend.

### 3.3. Pathfinding (A*)
*   Implemented on the backend.
*   Used for robot navigation to tasks/chargers and determining "nearest" entities.

### 3.4. Robot Movement & Collision Resolution
*   Backend updates robot locations based on `currentPath` and `movementCostPerCell`.
*   Backend implements collision/yielding logic (ID-based priority).
*   Backend handles deadlock prevention (path re-calculation).

### 3.5. Task Assignment Strategies
*   Implemented on the backend. The frontend will send the selected strategy choice.
*   **"Available" robot definition:** Managed by backend logic.
    *   **Strategy 1: Nearest Available Robot**
        *   "Nearest" is determined by the shortest navigable path length (A*).
        *   **Initial Assignment (at Sim Start):**
            1.  Iterate through tasks in order of placement.
            2.  For each task, find the nearest *currently available* robot.
            3.  Assign task to that robot. Mark robot as `en_route_to_task`.
        *   **Ongoing Assignment (when a robot becomes `idle`):**
            1.  The newly `idle` robot (if battery sufficient and not needing charge) proactively searches for the unassigned task nearest to *itself*.
            2.  If found, it assigns itself and becomes `en_route_to_task`.
    *   **Strategy 2: Round-Robin**
        *   Robots are considered in a fixed cycle based on their placement order.
        *   **Initial Assignment (at Sim Start):**
            1.  Iterate through tasks in order of placement.
            2.  For each task, offer it to the next robot in the round-robin sequence.
            3.  If that robot is "available," assign the task.
            4.  If not available, skip it and offer the *same task* to the *next* robot in the sequence.
        *   **Ongoing Assignment (when any robot becomes `idle` or a task is unassigned):**
            1.  The system considers unassigned tasks (e.g., oldest first).
            2.  For an unassigned task, it identifies the *next* robot in the global round-robin sequence.
            3.  If that specific robot is "available," the task is assigned to it. Otherwise, the task remains unassigned.
            4.  A newly `idle` robot does *not* proactively grab a task; it waits.
*   Backend handles unassignable tasks and re-evaluation logic.

### 3.6. Battery Management & Charging
*   Backend tracks and updates robot battery levels.
*   **Depletion:**
    *   Movement: `movementCostPerCell` per cell.
    *   Task Performance: `batteryCostToPerform` (one-time cost).
*   **Low Battery Threshold:** 20%.
*   **Decision to Charge:**
    *   If `idle` and `battery < 20%`, next goal is charging.
    *   Will attempt to complete current task even if battery drops below 20%.
*   **Charging Station Selection:** Backend uses A* to find the nearest.
*   **Charging Process:**
    *   Status `en_route_to_charger`, then `charging`.
    *   Fixed steps (e.g., 5) to full. Incremental or full at end.
    *   Status becomes `idle` when full.

### 3.7. Task Processing
*   When robot arrives at task:
    1.  Status `performing_task`.
    2.  `batteryCostToPerform` deducted.
    3.  Task status `in_progress`.
    4.  After `workDuration` steps, task `completed`.
    5.  Robot `idle`.

### 3.8. Simulation Start & End Conditions
*   Backend receives "Start" command. Performs initial task assignments.
*   Backend detects when all tasks are completed, ends the simulation, and potentially saves final metrics to Supabase.
*   Backend notifies clients of simulation end.

---

## 4. Frontend User Interface (UI) & Interaction (React)
*(Frontend is responsible for rendering and sending user commands to the backend.)*

### 4.1. Setup Phase
*   **Grid Selection:** Dropdown populates with grid names fetched from backend API (`GET /api/grids`). Selecting a grid fetches its layout for rendering.
*   **Item Placement Mode:**
    *   Buttons: "Place Task," "Place Robot."
    *   Clicking on a 'walkable' grid cell sends a request to the backend API (e.g., `POST /api/simulation/place-task`, `POST /api/simulation/place-robot`) with coordinates.
    *   Backend validates and confirms; frontend updates visually upon confirmation or displays error.
*   **Robot Icons:** Frontend cycles through 6-7 predefined PNGs for visual selection; the chosen `iconType` is sent to backend during robot placement.
*   **Strategy Selection:** Dropdown sends selected strategy to backend API (e.g., `POST /api/simulation/select-strategy`).

### 4.2. Simulation Controls
*   **"Start" Button:** Sends command to backend API (e.g., `POST /api/simulation/start`). Becomes disabled/changes to "Pause."
*   **"Pause/Resume" Button:** Sends commands to backend API (e.g., `POST /api/simulation/pause`, `POST /api/simulation/resume`).
*   **"Reset" Button:** Sends command to backend API (e.g., `POST /api/simulation/reset`). Backend resets its internal simulation state to initial placements/full battery/unassigned tasks. Frontend reflects this reset state.
*   **"Slower" / "Faster" Buttons:** Sends command to backend API (e.g., `POST /api/simulation/set-speed`) to adjust the backend's simulation step interval.

### 4.3. Visual Display
*   **Grid Rendering:** Renders grid based on data received from backend (initially and via WebSocket updates).
*   **Robot Rendering:**
    *   Displays robot icons based on `currentLocation` received via WebSocket updates.
    *   Animates movement locally between received state updates for smoother visuals.
    *   **Low Battery Indicator:** Frontend logic displays this based on battery level (`< 20%`) in received robot state. Temporary visual alert (3-5 seconds).
*   **Task Rendering:**
    *   Visual representation based on task state received via WebSocket updates.
    *   Spinning cogwheel animation for `in_progress` tasks triggered by state change.
*   **Paths (Optional Enhancement):** Frontend could render `currentPath` if included in WebSocket updates.

### 4.4. Information Display
*   A dedicated section lists all robots. For each robot:
    *   Robot ID (and/or icon type).
    *   Current battery level.
    *   Current intended destination (e.g., "Task T3 @ (5,2)" or "Charger @ (0,1)"). If idle, show "Idle".
*   Displays key metrics received via WebSocket updates.

---

## 5. Technical Architecture & Implementation Details

### 5.1. Core Technologies
*   **Backend:**
    *   Language: TypeScript
    *   Framework: Node.js, Express
    *   Real-time: `socket.io` (or `ws`)
    *   Database ORM/Client: Supabase Client (`@supabase/supabase-js`)
    *   Middleware: `cors`
*   **Frontend:**
    *   Language: TypeScript
    *   Framework: React
    *   Real-time Client: `socket.io-client`
*   **Database:** Supabase (PostgreSQL)

### 5.2. State Management
*   **Backend:**
    *   Manages the authoritative state of the *active* simulation (robots, tasks, grid, time) in memory.
    *   May use classes or structured objects for simulation entities.
    *   Supabase is used for persistent storage of *initial configurations* (grids) and *results* (metrics, potentially final states).
*   **Frontend:**
    *   Uses a state management solution (e.g., React Context with `useReducer`, Zustand, Redux Toolkit) to store and manage the UI state, which mirrors the simulation state received from the backend via WebSockets.

### 5.3. Communication (API & WebSockets)
*   **Backend API (RESTful):**
    *   `GET /api/grids`: Fetch list of available grid definitions.
    *   `GET /api/grids/:id`: Fetch specific grid layout.
    *   `POST /api/simulation/setup`: Endpoint to configure a new simulation session (e.g., selected grid, strategy).
    *   `POST /api/simulation/robots`: Add a robot to the current setup. Body: `{ location: {x, y}, iconType: string }`.
    *   `POST /api/simulation/tasks`: Add a task to the current setup. Body: `{ location: {x, y} }`.
    *   `POST /api/simulation/control/start`: Start the active simulation.
    *   `POST /api/simulation/control/pause`: Pause the active simulation.
    *   `POST /api/simulation/control/resume`: Resume the active simulation.
    *   `POST /api/simulation/control/reset`: Reset the active simulation to its initial setup.
    *   `POST /api/simulation/control/speed`: Adjust simulation speed. Body: `{ speedFactor: number }`.
    *   `POST /api/simulation/strategy`: Set the task assignment strategy. Body: `{ strategy: 'nearest' | 'round-robin' }`.
*   **WebSockets (Server -> Client):**
    *   `simulation_update`: (Emitted by backend periodically) Sends the current comprehensive state:
        ```json
        {
            "robots": [/* Array of Robot objects */],
            "tasks": [/* Array of Task objects */],
            "simulationTime": number, // current step
            "metrics": { /* Key Metrics object */ }
        }
        ```
    *   `simulation_ended`: (Emitted by backend) Notifies clients the simulation has concluded. Payload: `{ finalMetrics: { ... } }`.
    *   `initial_state`: (Emitted by backend upon client connection or after reset) Provides the full current setup (grid, placed items, selected strategy) before simulation starts.
        ```json
        {
            "grid": { /* Grid layout object */ },
            "robots": [/* Array of Robot initial state objects */],
            "tasks": [/* Array of Task initial state objects */],
            "selectedStrategy": string | null,
            "simulationStatus": "idle" | "running" | "paused"
        }
        ```
    *   `error_message`: (Emitted by backend) For backend-detected operational errors to display to user. Payload: `{ message: string }`.
*   **WebSockets (Client -> Server):**
    *   Primarily, commands use REST API. WebSocket client-to-server messages are generally not needed for this scope but could be considered for future highly interactive features.

### 5.4. Backend Modularity
*   `SimulationService`: Manages the overall simulation lifecycle, state, and step progression.
*   `GridService`: Handles loading grid data from Supabase.
*   `PathfindingService`: A* implementation.
*   `TaskAssignmentService`: Implements task assignment strategies.
*   `RobotController` / `TaskController`: (Conceptual) Classes or modules managing individual robot/task logic and state changes during simulation steps.
*   `WebSocketManager`: Handles WebSocket connections, rooms (if managing multiple simulations), broadcasting messages.
*   `APIRoutes`: Express routers and controllers for handling HTTP requests.
*   `SupabaseService`: Wrapper for interactions with Supabase (CRUD operations for grids, results).

### 5.5. Frontend Modularity
*   React Components for: `GridDisplay`, `RobotIcon`, `TaskIcon`, `ControlPanel`, `InfoPanel`, `SetupControls`.
*   `WebSocketService`: Manages WebSocket connection, event subscription, and data dispatch to state.
*   `APIService`: Handles communication with the backend REST API.
*   `hooks/`: Custom React hooks for managing shared logic or state.
*   `contexts/` or `store/`: For global state management.

### 5.6. Database (Supabase)
*   **Tables:**
    *   `grids`:
        *   `id`: `UUID` (Primary Key, default `gen_random_uuid()`)
        *   `name`: `TEXT` (Unique, Not Null)
        *   `layout`: `JSONB` (Stores the 2D array of `Cell` type definitions, Not Null)
        *   `created_at`: `TIMESTAMPTZ` (default `now()`)
    *   `simulation_results` (Optional, for storing metrics per run):
        *   `id`: `UUID` (PK, default `gen_random_uuid()`)
        *   `grid_id`: `UUID` (FK to `grids.id`, On Delete Cascade)
        *   `strategy_used`: `TEXT`
        *   `completion_time_steps`: `INTEGER`
        *   `total_recharges`: `INTEGER`
        *   `num_robots`: `INTEGER`
        *   `num_tasks`: `INTEGER`
        *   `run_at`: `TIMESTAMPTZ` (default `now()`)
*   **Backend will interact with Supabase to:**
    *   Fetch grid definitions.
    *   Save simulation metrics/results upon completion (if `simulation_results` table is implemented).

---

## 6. Key Metrics for Comparison
*   Calculated by the backend.
*   Broadcast to frontend via WebSockets as part of `simulation_update` or `simulation_ended`.
*   Optionally stored in Supabase `simulation_results` table.
    1.  **Total Simulated Time to Complete All Tasks:** (simulated seconds/steps)
    2.  **Total Number of Recharges:** (Sum of times any robot completed a charging cycle)

---

## 7. Error Handling & Edge Cases
*   **Backend Validation:** Backend validates all incoming data from frontend (e.g., placement coordinates within grid bounds and on 'walkable' cells, valid strategy choice).
*   **API Error Responses:** Backend uses standard HTTP error codes (e.g., 400, 404, 500) and JSON error messages.
*   **WebSocket Error Messages:** Backend can send specific `error_message` events via WebSockets.
*   **No Path Found:** Backend A* should return an indicator (e.g., empty path or null). Robot/system needs to handle this (task remains unassigned, robot tries alternative charger or remains idle).
*   **All Robots Stranded:** Simulation may stall. This is an observable outcome.
*   **No Tasks/Robots:** Backend may prevent starting simulation or it runs trivially. Frontend should guide user.
*   **Supabase Connectivity:** Backend should handle potential Supabase errors gracefully (e.g., log error, inform client if critical like grid loading fails).
*   **Client Disconnection/Reconnection:**
    *   Simulation on backend continues.
    *   Reconnecting client receives `initial_state` (or current `simulation_update` if in progress) to sync up.
    *   The single active simulation instance on the backend is shared by all connected clients.

---

## 8. Testing Plan

### 8.1. Backend Unit Tests (e.g., Jest/Vitest)
*   `PathfindingService` (A*): Correct paths, obstacle handling, no path.
*   Robot/Task logic: State transitions, battery math, charging logic.
*   `TaskAssignmentService` strategies: Correct robot selection in various scenarios.
*   Collision & Yielding logic.
*   `GridService` (mocking Supabase calls for fetching grids).
*   API Controller unit tests (mocking services, validating request/response).

### 8.2. Frontend React Component Tests (e.g., React Testing Library)
*   Rendering of components based on props (mocked state from backend).
*   User interactions (button clicks) and verifying correct API calls or WebSocket service interactions are triggered.
*   Display of information panel and metrics.

### 8.3. Integration Tests
*   **Backend:**
    *   Test API endpoints with `supertest`, verifying responses and database interactions (if applicable, with a test DB or mocking).
    *   Test interactions between backend services.
    *   Test WebSocket broadcasting logic (e.g., mock clients).
*   **Frontend-Backend (Conceptual):**
    *   Frontend: Testing components with mocked WebSocket server and HTTP API responses.
    *   Focus on contract adherence between client and server.

### 8.4. End-to-End (E2E) Tests (e.g., Cypress or Playwright)
*   Full user workflow:
    1.  Client connects, selects grid (data from backend/Supabase).
    2.  Places tasks/robots (commands to backend, state updates via WebSockets).
    3.  Selects strategy, starts simulation.
    4.  Observe real-time visual updates on frontend.
    5.  Verify simulation completion and final metrics.
*   Test with multiple browser instances (clients) connected, observing the same simulation.
*   Test Pause/Resume, Reset, Speed controls.
*   Test edge cases like no path available, low battery scenarios.

---

## 9. Future Considerations (Beyond initial scope)
*   Different task types (varied durations, priorities, costs - potentially stored in Supabase).
*   Different robot types (varied speeds, battery, abilities - configurations in Supabase).
*   User authentication (e.g., Supabase Auth) to allow users to save/load their *own* simulation setups.
*   Saving and loading complete simulation *setups* (grid, item placements, strategy) to Supabase, associated with a user or publicly.
*   More sophisticated "room" or "session" management on the backend to allow multiple independent simulations to be run by different users/groups concurrently.
*   Admin interface/tools for managing grid definitions in Supabase directly.
*   More detailed analytics and charting of performance metrics (e.g., robot utilization, average task completion time).
*   Dynamic event injection (e.g., new tasks appearing, obstacles appearing/disappearing during simulation).